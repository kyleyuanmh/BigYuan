## 程序中错误处理
传统的处理错误方式是错误码，通过return来知道该函数的执行情况，比如C、C++就是这样，他们通过错误码和全局变量errorno配合来了解具体出了什么错误。

为什么这么设计，左耳听风说了“道理很简单，除了可以共用一些错误，更重要的是这其实是一种妥协。比如：read(), write(), open() 这些函数的返回值其实是返回有业务逻辑的值。也就是说，这些函数的返回值有两种语义，一种是成功的值，比如 open() 返回的文件句柄指针 FILE* ，或是错误 NULL。这样会导致调用者并不知道是什么原因出错了，需要去检查 errno 来获得出错的原因，从而可以正确地处理错误。”

### 多返回值
GO语言支持多返回值，很多函数都会返回 result, err 两个值：
- 参数上基本上就是入参，而返回接口把结果和错误分离，这样使得函数的接口语义清晰；
- Go 语言中的错误参数如果要忽略，需要显式地忽略，用 _ 这样的变量来忽略
- 因为返回的 error 是个接口（其中只有一个方法 Error()，返回一个 string ），所以你可以扩展自定义的错误处理。

如果一个函数返回了多个不同类型的 error，你也可以使用下面这样的方式：
```
if err != nil {
  switch err.(type) {
    case *json.SyntaxError:
      ...
    case *ZeroDivisionError:
      ...
    case *NullPointerError:
      ...
    default:
      ...
  }
}
```

左耳听风说的很对：但即便像 Go 这样的语言能让错误处理语义更清楚，而且还有可扩展性，也有其问题。如果写过一段时间的 Go 语言，你就会明白其中的痛苦—— if err != nil 这样的语句简直是写到吐，只能在 IDE 中定义一个自动写这段代码的快捷键……而且，正常的逻辑代码会被大量的错误处理打得比较凌乱。

因为你会发现Go语言几乎所有的函数都有可能返回err,因此你会觉得步履维艰，每一步都要排查错误，并作出相应处理，难搞。

### 资源清理

有些函数需要昨晚之后释放资源，在释放资源之前，绝对不能return，因为一旦return，后面释放资源的代码就不能执行到，这样就内存泄露了，比如：
```

#define FREE(p) if(p) { \
                    free(p); \
                    p = NULL; \
                 }
main()
{
  char *fname=NULL, *lname=NULL, *mname=NULL;
  fname = ( char* ) calloc ( 20, sizeof(char) );
  if ( fname == NULL ){
      goto fail;
  }
  lname = ( char* ) calloc ( 20, sizeof(char) );
  if ( lname == NULL ){
      goto fail;
  }
  mname = ( char* ) calloc ( 20, sizeof(char) );
  if ( mname == NULL ){
      goto fail;
  }
    
  ......
 
fail:
  FREE(fname);
  FREE(lname);
  FREE(mname);
  ReportError(ERR_NO_MEMORY);
} 
```
这是一个内存释放的例子，另外一个典型的例子是**锁**，就是因为上锁和解锁必须成对存在，有时候上了锁，忘记了解锁，那么就会很容易死锁，这在高并发的常见很容易存在。

C++使用LockGuard类对象来对锁进行分装，通过构造函数上锁，析构函数解锁，因为析构函数自动被调用，因此就不用担心没有解锁。看看左耳听风给的例子
```
//首先，先声明一个RAII类，注意其中的构造函数和析构函数
class LockGuard {
public:
  LockGuard(std::mutex &m):_m(m) { m.lock(); }
  ~LockGuard() { m. unlock(); }
private:
  std::mutex& _m;
}


//然后，我们来看一下，怎样使用的
void good()
{
  LockGuard lg(m);           // RAII类：构造时，互斥量请求加锁
  f();                             // 若f()抛异常，则释放互斥
  if(!everything_ok()) return;     // 提早返回，LockGuard析构时，互斥量被释放
}                                    // 若good()正常返回，则释放互斥
```
为了防止程序员忘记解锁，GO语言的defer关键字可以帮助将解锁动作代码提前，而实际的动作执行往后延迟，很不错的解决方案。

### 异常处理

try - catch - finally
```
try {
  ... // 正常的业务代码
} catch (Exception1 e) {
  ... // 处理异常 Exception1 的代码
} catch (Exception2 e) {
  ... // 处理异常 Exception2 的代码
} finally {
  ... // 资源清理的代码
}
```
好处：
- 函数接口在 input（参数）和 output（返回值）以及错误处理的语义是比较清楚的。
- 正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。
- 异常不能被忽略（如果要忽略也需要 catch 住，这是显式忽略）。
- 在面向对象的语言中（如 Java），异常是个对象，所以，可以实现多态式的 catch。
- 与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用。比如：int x = add(a, div(b,c)); 或 Pizza p = PizzaBuilder().SetSize(sz) .SetPrice(p)...; 。

try - catch - finally 有个致命的问题，那就是在异步运行的世界里的问题。try 语句块里的函数运行在另外一个线程中，其中抛出的异常无法在调用者的这个线程中被捕捉。这个问题就比较大了。

### 错误返回码 vs 异常捕捉

错误分类：

- **资源的错误。** 当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的文件，写文件时出现的写错误，发送文件到网络端发现网络故障的错误，等等。**这一类错误属于程序运行环境的问题。对于这类错误，有的我们可以处理，有的我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。**
- **程序的错误** 比如：空指针、非法参数等。这类是我们自己程序的错误，我们要记录下来，写入日志，最好触发监控系统报警。
- **用户的错误** 比如：Bad Request、Bad Format 等这类由用户不合法输入带来的错误。这类错误基本上是在用户的 API 层上出现的问题。比如，解析一个 XML 或 JSON 文件，或是用户输入的字段不合法之类的。

我们可以这样来在逻辑上分类：
- 对于我们并不期望会发生的事，我们可以使用异常捕捉；
- 对于我们觉得可能会发生的事，使用返回码。

比如函数传进来一个不符合规范的，使我们不期望发生的，这时候我们就可以通过状态码来完成，具体是错在什么地方，调用者传进来什么类型，或者传来的空的。

而第二种是那种用法本身没错，而是出于我们为了代码更加健壮，想到的一些预测错误的方案，比如用户的错误，我们使用状态码比较合适，

这是一个原则问题，并不是百分之百要这么做。

有些情况只能选择一种：
- 在 C++ 重载操作符的情况下，你就很难使用错误返回码，只能抛异常；
- 异常捕捉只能在同步的情况下使用，在异步模式下，抛异常这事就不行了，需要通过检查子进程退出码或是回调函数来解决；
- 在分布式的情况下，调用远程服务只能看错误返回码，比如 HTTP 的返回码。


> 左耳听风